---
title: "Unit 1 - Your first day with the Julia language"
engine: julia
---

# Story: Finding the max (loops, functions, variables, plotting)

```{julia}
using Random

function find_max(data)
    max_value = -Inf
    for x in data
        if x > max_value
            max_value = x
        end
    end
    return max_value
end

Random.seed!(0)
data = rand(100)
max_value = find_max(data)
println("Found maximal value: $(max_value)")
```

```{julia}
using Random

function find_max(data)
    max_value = -Inf
    n = 0
    for x in data
        if x > max_value
            n = n+1
            max_value = x
        end
    end
    return max_value, n
end

Random.seed!(0)
data = rand(100)
max_value, n = find_max(data)
println("Found maximal value: $(max_value)")
println("There were $n records along the way.")
```

How many on average? Denote the number of records for $n$ data points by $X_n$ then,
$$
X_n = I_1 + I_2 + \ldots + I_n,
$$
where,
$$
I_i =
\begin{cases}
1 & \text{if}~i~\text{'th data point is a record}, \\
0 & \text{otherwise}.
\end{cases}
$$
Now,
$$
{\mathbb E}[X_n] = {\mathbb E}[I_1] + {\mathbb E}[I_2] + \ldots + {\mathbb E}[I_n]. 
$$
Observe that ${\mathbb E}[I_i] = {\mathbb P}(I_i = 1)$ and for statistically independent and identically distributed data points we have,
$$
{\mathbb P}(I_i = 1) = \frac{1}{i},
$$
why? 

Hence,
$$
{\mathbb E}[X_n] = h_n = \sum_{i=1}^n \frac{1}{i},
$$
the harmonic sum. It is known that
$$
h_n = \log(n) + \gamma + o(1),
$$
where $\gamma$ is the [Euler–Mascheroni constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant) and $o(1)$ is a term that vanishes as $n \to \infty$. That is 
$$
h_n \approx \log(n) + \gamma.
$$
Let's see it...
```{julia}
using Plots

println("γ = ",Float64(MathConstants.γ))  #\gamma + [TAB]

h(n) = sum(1/i for i in 1:n)
approx_h(n) = log(n) + MathConstants.γ

for n in 1:10
    println(n, "\t", h(n), "\t", approx_h(n) )
end

err = [h(n) - approx_h(n) for n in 1:20]

scatter(1:20,err,xticks=1:20,xlabel="n",ylabel = "Error",ylim = (0,0.5), legend=false)
```

Here is a Monte Carlo estimate and a histogram of the distribution:

```{julia}
using Statistics

records = []

for s in 1:10^5
    Random.seed!(s)
    data = rand(100)
    _, n = find_max(data)
    push!(records,n)
end
println("log(100) + γ =  $(approx_h(100)), Monte Carlo Estimate: $(mean(records))")

histogram(records,ticks = 1:maximum(records),normed=true,xlabel="n",ylabel="probability",legend=false)
```

# Where to run Julia

* Shell
* REPL
* VS-CODE
* Jupyter
* Pluto
* Quarto
* Weave (legacy)

# The Package Manager

* REPL via `]`
* The `Pkg` package

## Environment/package management in Julia

Python <> Julia correspondence?

`julia --project` OR `julia` then `]` then `activate .`

Then `instantiate` to do `pip install -r requirements.txt` but it's better

`source venv/bin/active && pip install -r requirements.txt` <> `julia --project > ] > instantiate`

# Story: Computing Square Roots (multiple dispatch, types, LLVM)

* Basics
* Variables (also complex types)
* Types (basic story about types)
* Many methods for the one function
* The Babylonian algorithm 
* Broadcasting as well
* The "quakeIII" algorithm for the reciprocal of square root Float32 

```{julia}
sqrt(25)
```

```{julia}
x = sqrt(2)
@show x, x^2

x = sqrt(2f0) #32 bit float (Float32)
@show x, x^2
```

```{julia}
sqrt(-1)
```

```{julia}
sqrt(Complex(-1))
```
```{julia}
√2 #\sqrt + [TAB]
```

In Julia a function (such as `sqrt` or its alias `√`) can have many methods:

```{julia}
using InteractiveUtils
@which sqrt(2)
```

```{julia}
@which sqrt(2.0)
```

```{julia}
@which sqrt(π*im) #\pi + [Tab]
```

What if we wanted to apply square root to several/many elements together? It is common to use the `.` broadcast operator.

```{julia}
data = [i^2 for i in 0:10]
sqrt.(data) # The "." broadcating operator
```

How can we compute the square root if we didn't have the `sqrt()` function? Of course one answer is to use another in-built alternative:

```{julia}
x = 36
@show x^0.5
```

But how is such an algorithm implemented? In Julia's source code, in [`math.jl`](https://github.com/JuliaLang/julia/blob/master/base/math.jl) you'll find the following in lines 566-569:

```
@inline function sqrt(x::Union{Float32,Float64})
    x < zero(x) && throw_complex_domainerror(:sqrt, x)
    sqrt_llvm(x)
end
```

Here `sqrt_llvm()` compiles to [Low Level Virtual Machine(LLVM)](https://en.wikipedia.org/wiki/LLVM), so while many functions in Julia are actually implemented in Julia, with square roots it is better to let the underlying low level (LLVM) code handle square roots because it is later changed to assembly code; which is very fast. You can inspect this via the macros `@code_llvm` and `@code_native`.  

This will generally look the same on different computer types (LLVM is hardware agnostic):

```{julia}
@code_llvm sqrt(2.5)
```

This will look different for different computer types (cpus):

```{julia}
@code_native sqrt(2.5)
```

However, what if we wanted to do square roots via software? For example,

```{julia}
sqrt(big(10)^100)
```

What are (in principle) some [methods to compute square roots](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots)? Let's look at them and implement them.

One method is the [Babylonian algorithm](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method): Say we are given a positive real number $z$ and want its square root. We start with an initial guess $x_0$. We then apply the recursive step,

$$
x_{k+1} = \frac{1}{2}\Big(x_k+\frac{z}{x_k}\Big).
$$
That is, at each step the next iterate is the arithmetic mean of the previous iterate, $x_k$, and $z/x_k$. The Babylonian algorithm runs this iteration until convergence (note the default initial guess in this implementation is $z/2$):

```{julia}
function bab_sqrt(z ; init_x = z/2, verbose = false, tol = 1e-10)
    x = init_x
    while true
        verbose && println("Babylonian iterate: $x")
        next_x = 0.5*(x + z / x)
        abs(next_x - x) < tol && break
        x = next_x
    end
    x
end

bs, s = bab_sqrt(5000;verbose = true), sqrt(5000)
println("Babylonian:\t$bs\nSystem:\t\t$s")
```

We can view the ancient Babylonian method as an application of the more general [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method) for solving equations. Our goal is to solve $x^2 = z$ where $z$ is given and $x$ is desired. That is define $f(x) = x^2 - z$ and we wish to find the solution of $f(x) = 0$. Newton's method iterates,

$$
x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)},
$$

based on an affine (linear) approximation of $f(\cdot)$ at the point $x_k$. Here $f'(\cdot)$ is the derivative, which in our case is $f'(x) = 2x$. So Newton's iterates for finding the square root are,

$$
x_{k+1} = x_k - \frac{x_k^2-z}{2 x_k} = \frac{x_k}{2} + \frac{z}{2x_k} = \frac{1}{2}\Big(x_k+\frac{z}{x_k}\Big).
$$

Sometimes we are not just interested in computing the $\sqrt{z}$, but rather,

$$
\frac{1}{\sqrt{z}}.
$$

A common case for that is when we have a vector, say $u = [u_1, u_2]$ and we wish to create the normalized (unit $L_2$ norm) vector,

$$
\overline{u} = \frac{1}{\|u\|} u = \frac{1}{\sqrt{u_1^2 + u_2^2}} u.
$$



# Story: Computing Factorials (special functions, big numbers, more on types)

* Basics
* Recursion
* BigInts
* The Gamma function
* Accuracy of the Stirling approximation (will use arrays also for plotting)

A few basic ways to compute $10! = 1\cdot 2 \cdot \ldots \cdot 10$:

```{julia}
f_a = factorial(10)
@show f_a

f_b = *(1:10...)
@show f_b

f_c = last(accumulate(*,1:10))
@show f_c

f_d = 1
for i in 1:10
    global f_d *= i
end
@show f_d;
```

Observe that,

$$
n! = 
\begin{cases}
n \cdot (n-1)! & n = 1,2,\ldots\\
1 & n = 0.
\end{cases}
$$

This is a recursive definition. Let's implement it:

```{julia}
function my_factorial(n)
    if n == 0
        return 1
    else
        return n * my_factorial(n-1)
    end
end

my_factorial(10)
```

Let's see what happens with this recursion:

```{julia}
function my_factorial(n)
    println("Calling my_factorial($n)")
    if n == 0
        ret_val = 1
    else
        ret_val = n * my_factorial(n-1)
    end
    println("Returning from the call of my_factorial($n)")
    ret_val
end

my_factorial(10)
```
You can also use the [`stracktrace()`](https://docs.julialang.org/en/v1/manual/stacktraces/) function.


Here is the `my_factorial()` function (written compactly).

```{julia}
my_factorial(n) = n == 0 ? 1 : n*my_factorial(n-1)

my_factorial(10)
```

Such compact writing does not change what actually happens under the hood. To see this consider both forms:

```{julia}
my_factorial1(n) = n == 0 ? 1 : n*my_factorial1(n-1)

function my_factorial2(n)
    if n == 0
        return 1
    else
        return n * my_factorial2(n-1)
    end
end
```

And use Julia's `@code_lowered` macro to see how Julia parses the code into an intermediate representation (before being further compiled to LLVM). In both forms we get the exact same intermediate form.

```{julia}
@code_lowered my_factorial1(10)
```

```{julia}
@code_lowered my_factorial2(10)
```

How large can factorials we compute be? With `BigInt`, created via `big()`, there is sometimes no limit, but if we wanted to stay within the machine word size, we stay with `Int64` (with Julia `Int` is either `Int32` on "32 bit machines" or `Int64` on "64 bit machines). But even 32 bit machines support 64 bit integers (by doubling words).

Lets first use [Stirling's approximation](https://en.wikipedia.org/wiki/Stirling%27s_approximation) to get an estimate of the largest factorial we can compute with `UInt64`.

$$
n! \sim \sqrt{2 \pi} \, n^{n+\frac{1}{2}} e^{-n}
$$

To see the approximation isn't unreasonable, observe that $n! \le n^n$ (why?) but isn't so far either. 
```{julia}
#An array of named tuples (note that "n!" is just a name)
[(n! = factorial(n), n2n = n^n, ratio = factorial(n)/(n^n)) for n in 1:10]
```

The other $\sqrt{n} e^{-n}$ factor of $n$ in Stirling, corrects for this and $\sqrt{2 \pi}$ is a constant.


```{julia}
stirling(n) = (√(2π*n))*(n/MathConstants.e)^n      

[(  n! = factorial(n), 
    stirling = stirling(n), 
    ratio = round(factorial(n)/stirling(n),digits = 5)) 
    for n in 1:10]
```

So let's use Stirling to see how big $n$ can be to fit in `UInt64`. That is solve 
$$
\sqrt{2 \pi} \, n^{n+\frac{1}{2}} e^{-n}  = 2^{64}-1.
$$
There are multiple ways to try to do this. We'll use floating point numbers and just search. Observe this:

```{julia}
2^64-1, typeof(2^64-1) #This is a signed integer by default
```

```{julia}
UInt(2)^64-1, typeof(UInt(2)^64-1) #unsigned
```

```{julia}
println(UInt(2)^64-1)
```

See also the documentation about [Integers and Floating-Point Numbers](https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Integers-and-Floating-Point-Numbers).

With floating point we can do much more:
```{julia}
2.0^64-1, typeof(2.0^64-1)
```
In general,
```{julia}
@show typemax(Int64)
@show typemax(UInt64)
@show typemax(Float64);
```

Here is the search (to simplify let's focus on signed integers): 

```{julia}
limit = typemax(Int64)
n = 1
while stirling(n) <= limit
    global n += 1
end
n -= 1 #why is this here? What can be done instead?
println("Found maximal n for n! with 64 bits to be $n.")
```

Let's try it:

```{julia}
factorial(20)
```

What about $n=21$?

```{julia}
factorial(21)
```

Indeed $n=21$ doesn't fit within the 64 bit limit.  However as suggested by the error message, using `big()` can help:

```{julia}
typeof(big(21))
```

```{julia}
factorial(big(21))
```

With (software) big integers everything goes:

```{julia}
n = 10^3
big_stuff = factorial(big(n));
num_digits = Int(ceil(log10(big_stuff))) 
println("The facotrial of $n has $num_digits decimal digits.") 
```

What about factorials of numbers that aren't positive integers?

```{julia}
factorial(6.5)
```

No, that isn't defined. But you may be looking for the [gamma](https://en.wikipedia.org/wiki/Gamma_function) special function:

$$
\Gamma(z)=\int_{0}^{\infty} x^{z-1} e^{-x} d x.
$$

```{julia}
using SpecialFunctions #You'll need to add (install) SpecialFunctions

gamma(6.5)
```

To feel more confident this value agrees with the integral definition of $\Gamma(\cdot)$; let's compute the integral in a very crude manner ([Riemann_sum](https://en.wikipedia.org/wiki/Riemann_sum)):

```{julia}
function my_crude_gamma(z; delta= 0.01, M = 50)
    integrand(x) = x^(z-1)*exp(-x) 
    x_grid = 0:delta:M
    sum(delta*integrand(x) for x in x_grid)
end

my_crude_gamma(6.5)
```
Now note that the gamma function is sometimes considered as the continuous version of the factorial because,
$$
\begin{aligned}
\Gamma(z+1) &=\int_{0}^{\infty} x^{z} e^{-x} d x \\
&=\left[-x^{z} e^{-x}\right]_{0}^{\infty}+\int_{0}^{\infty} z x^{z-1} e^{-x} d x \\
&=\lim _{x \rightarrow \infty}\left(-x^{z} e^{-x}\right)-\left(-0^{z} e^{-0}\right)+z \int_{0}^{\infty} x^{z-1} e^{-x} d x \\
&=z \, \Gamma(z).
\end{aligned}
$$

That is, the recursive relationship $\Gamma(z+1) = z\Gamma(z)$ holds similarly to $n! = n \cdot n!$. Further 
$$
\Gamma(1) = \int_0^\infty e^{-x} \, dx = 1.
$$
Hence we see that for integer $z$, $\Gamma(z) = (z-1)!$ or $n! = \Gamma(n+1)$. Let's try this.

```{julia}
using SpecialFunctions
[(n = n, n! = factorial(n), Γ = gamma(n+1)) for n in 0:10]
```

The gamma function can also be extended outside of the positive reals. At some points it isn't defined though.

```{julia}
@show gamma(-1.1) #here defined.
gamma(-1) #here not defined
```

Here is a plot where we exclude certain points where it isn't defined

```{julia}
using Plots, SpecialFunctions

z = setdiff(-3:0.001:4, -3:0) #setdifference to remove points where gamma() returns a NaN   
plot(z,gamma.(z), ylim=(-7,7),legend=false,xlabel="z",ylabel = "Γ(z)")
```

QQQQ - Put in `eps()` computation

QQQQ - Put in type hierarchy

# Integrating with R and Python

